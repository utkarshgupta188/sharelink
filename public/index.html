<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P File Sharing</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: Arial, sans-serif; background: #f5f5f5; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; background: white; border-radius: 8px; padding: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .header { text-align: center; margin-bottom: 30px; color: #333; }
        .section { margin-bottom: 30px; padding: 20px; border: 1px solid #ddd; border-radius: 6px; }
        .section h3 { margin-bottom: 15px; color: #555; }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 5px; font-weight: bold; }
        .form-group input, .form-group select { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; }
        .btn { background: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px; }
        .btn:hover { background: #0056b3; }
        .btn-success { background: #28a745; }
        .btn-danger { background: #dc3545; }
        .status { padding: 10px; border-radius: 4px; margin: 10px 0; }
        .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .status.info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .file-list, .peer-list { list-style: none; }
        .file-item, .peer-item { padding: 10px; border: 1px solid #eee; margin-bottom: 5px; border-radius: 4px; background: #f9f9f9; }
        .file-item:hover, .peer-item:hover { background: #f0f0f0; }
        .hidden { display: none; }
        .two-column { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        @media (max-width: 768px) { .two-column { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîÑ P2P File Sharing</h1>
            <p>Secure peer-to-peer file sharing with OTP authentication</p>
        </div>

        <div class="section">
            <h3>üë§ Peer Registration & Authentication</h3>
            <div class="form-group">
                <label for="username">Username:</label>
                <input type="text" id="username" placeholder="Enter your username">
            </div>
            <button class="btn" onclick="registerPeer()">Register as Peer</button>
            
            <div id="otp-section" class="hidden">
                <div class="form-group">
                    <label for="otp">Enter OTP:</label>
                    <input type="text" id="otp" placeholder="6-digit OTP">
                </div>
                <button class="btn btn-success" onclick="authenticateWithOTP()">Authenticate</button>
            </div>
            
            <div id="status"></div>
        </div>

        <div class="two-column">
            <div class="section">
                <h3>üìÅ File Upload</h3>
                <div class="form-group">
                    <label for="fileInput">Select File:</label>
                    <input type="file" id="fileInput">
                </div>
                <button class="btn" onclick="uploadFile()">Upload File</button>
            </div>

            <div class="section">
                <h3>üë• Connected Peers</h3>
                <ul id="peerList" class="peer-list"></ul>
                <button class="btn" onclick="refreshPeers()">Refresh Peers</button>
            </div>
        </div>

        <div class="section">
            <h3>üìã Available Files</h3>
            <ul id="fileList" class="file-list"></ul>
            <button class="btn" onclick="refreshFiles()">Refresh Files</button>
        </div>
    </div>

    <script>
        let socket;
        let currentPeerId = null;
        let isAuthenticated = false;

        // Initialize socket connection
        function initSocket() {
            socket = io();
            
            socket.on('connect', () => {
                showStatus('Connected to server', 'success');
            });

            socket.on('peer:registered', (data) => {
                currentPeerId = data.peerId;
                showStatus(`Registered as peer: ${currentPeerId}`, 'success');
                generateOTP();
            });

            socket.on('auth:success', () => {
                isAuthenticated = true;
                showStatus('Authentication successful!', 'success');
                document.getElementById('otp-section').classList.add('hidden');
                refreshPeers();
                refreshFiles();
            });

            socket.on('auth:failed', (data) => {
                showStatus(`Authentication failed: ${data.message}`, 'error');
            });

            socket.on('peers:updated', (data) => {
                updatePeerList(data.peers);
            });

            socket.on('file:incoming', (data) => {
                showStatus(`File shared by ${data.fromPeer.username}`, 'info');
                refreshFiles();
            });
        }

        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            statusDiv.className = `status ${type}`;
            statusDiv.textContent = message;
        }

        async function registerPeer() {
            const username = document.getElementById('username').value.trim();
            if (!username) {
                showStatus('Please enter a username', 'error');
                return;
            }

            socket.emit('peer:register', { username });
        }

        async function generateOTP() {
            try {
                const response = await fetch('/api/otp/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ peerId: currentPeerId })
                });

                const data = await response.json();
                if (response.ok) {
                    showStatus(`Your OTP: ${data.token} (Valid for 5 minutes)`, 'info');
                    document.getElementById('otp-section').classList.remove('hidden');
                } else {
                    showStatus(`Error: ${data.error}`, 'error');
                }
            } catch (error) {
                showStatus('Failed to generate OTP', 'error');
            }
        }

        async function authenticateWithOTP() {
            const otp = document.getElementById('otp').value.trim();
            if (!otp || !currentPeerId) {
                showStatus('Please enter OTP', 'error');
                return;
            }

            try {
                const response = await fetch('/api/otp/verify', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token: otp, peerId: currentPeerId })
                });

                const data = await response.json();
                if (!response.ok) {
                    showStatus(`Authentication failed: ${data.error}`, 'error');
                }
            } catch (error) {
                showStatus('Authentication failed', 'error');
            }
        }

        async function uploadFile() {
            if (!isAuthenticated) {
                showStatus('Please authenticate first', 'error');
                return;
            }

            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            if (!file) {
                showStatus('Please select a file', 'error');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);
            formData.append('peerId', currentPeerId);

            try {
                const response = await fetch('/api/files/upload', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();
                if (response.ok) {
                    showStatus('File uploaded successfully!', 'success');
                    fileInput.value = '';
                    refreshFiles();
                } else {
                    showStatus(`Upload failed: ${data.error}`, 'error');
                }
            } catch (error) {
                showStatus('Upload failed', 'error');
            }
        }

        async function refreshFiles() {
            try {
                const response = await fetch('/api/files');
                const data = await response.json();
                updateFileList(data.files || []);
            } catch (error) {
                showStatus('Failed to refresh files', 'error');
            }
        }

        async function refreshPeers() {
            socket.emit('peer:discover');
        }

        function updateFileList(files) {
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = '';

            files.forEach(file => {
                const li = document.createElement('li');
                li.className = 'file-item';
                li.innerHTML = `
                    <strong>${file.originalName}</strong> 
                    (${formatFileSize(file.size)}) 
                    <small>by ${file.ownerId}</small>
                    <button class="btn" onclick="downloadFile('${file.id}', '${file.originalName}')" style="float: right; margin-left: 10px;">Download</button>
                `;
                fileList.appendChild(li);
            });
        }

        function updatePeerList(peers) {
            const peerList = document.getElementById('peerList');
            peerList.innerHTML = '';

            peers.forEach(peer => {
                if (peer.id !== currentPeerId) {
                    const li = document.createElement('li');
                    li.className = 'peer-item';
                    li.innerHTML = `
                        <strong>${peer.username}</strong> 
                        <small>(${peer.id})</small>
                        <small>Connected: ${new Date(peer.connectedAt).toLocaleTimeString()}</small>
                    `;
                    peerList.appendChild(li);
                }
            });
        }

        function downloadFile(fileId, filename) {
            window.open(`/api/files/${fileId}/download`, '_blank');
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Initialize the application
        initSocket();
    </script>
</body>
</html>
            } else {
                status.textContent = '‚ùå Disconnected';
                status.className = 'connection-status disconnected';
            }
        }
        
        // Global P2P File sharing system
        
        // Global variables for P2P
        // let localFiles = new Map(); // Files stored locally in browser - already declared above
        let peerConnections = new Map(); // WebRTC connections
        // let currentOTP = null; // already declared above

        // WebRTC configuration with enhanced settings for production deployment
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' }
            ],
            iceCandidatePoolSize: 10, // Generate more ICE candidates for better connectivity
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            iceTransportPolicy: 'all'
        };

        async function uploadFile() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                showStatus('uploadStatus', 'Please select a file first.', 'error');
                return;
            }
            
            // Check file size (1GB limit for P2P)
            const maxSize = 1024 * 1024 * 1024; // 1GB in bytes
            console.log(`üìè File size: ${file.size} bytes (${formatFileSize(file.size)})`);
            
            if (file.size > maxSize) {
                showStatus('uploadStatus', `File too large! Maximum size is 1GB. Your file is ${formatFileSize(file.size)}.`, 'error');
                return;
            }
            
            try {
                showStatus('uploadStatus', `Announcing ${file.name} (${formatFileSize(file.size)}) to P2P network...`, 'info');
                console.log('ÔøΩ Announcing file to P2P network:', {
                    name: file.name,
                    size: file.size,
                    type: file.type
                });
                
                // Convert file to ArrayBuffer for P2P transfer
                const arrayBuffer = await file.arrayBuffer();
                
                // Announce file to P2P network (no upload to server)
                const response = await fetch('/api/announce-file', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        fileName: file.name,
                        fileType: file.type,
                        fileSize: file.size,
                        uploaderId: socket.id || 'anonymous'
                    })
                });
                
                console.log('üì° Announcement response status:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Announcement failed with status ${response.status}: ${errorText}`);
                }
                
                const result = await response.json();
                console.log('üìã Server response:', result);
                
                if (result.success) {
                    // Store file locally for P2P sharing
                    localFiles.set(result.otp, {
                        file: arrayBuffer,
                        fileName: file.name,
                        fileType: file.type,
                        fileSize: file.size,
                        announcedAt: new Date()
                    });
                    
                    currentOTP = result.otp;
                    
                    // Also announce via Socket.IO for real-time P2P coordination
                    socket.emit('announce-file', {
                        otp: result.otp,
                        fileName: file.name,
                        fileType: file.type,
                        fileSize: file.size
                    });
                    console.log('üì° File also announced via Socket.IO for P2P coordination');
                    
                    showStatus('uploadStatus', 'File announced to P2P network! File stays on your device.', 'success');
                    displayOTP(result.otp);
                    console.log('‚úÖ File announced successfully, OTP:', result.otp);
                    
                    // Announce to connected peers via WebSocket
                    socket.emit('announce-file', {
                        otp: result.otp,
                        fileName: file.name,
                        fileSize: file.size,
                        fileType: file.type
                    });
                } else {
                    showStatus('uploadStatus', 'Announcement failed: ' + result.error, 'error');
                    console.error('‚ùå Announcement failed:', result.error);
                }
                
            } catch (error) {
                showStatus('uploadStatus', 'Announcement error: ' + error.message, 'error');
                console.error('‚ùå Announcement error:', error);
            }
        }
        
        // Generate 6-digit OTP locally
        function generateOTP() {
            return Math.floor(100000 + Math.random() * 900000).toString();
        }
        
        // True P2P OTP verification and file download
        async function verifyOTP() {
            const otp = document.getElementById('otpInput').value.trim();
            
            if (!otp || otp.length !== 6) {
                showStatus('downloadStatus', 'Please enter a valid 6-digit OTP.', 'error');
                return;
            }
            
            try {
                showStatus('downloadStatus', 'Searching P2P network for file...', 'info');
                console.log('üîç Requesting file from P2P network, OTP:', otp);
                
                // First verify OTP with server, then request P2P transfer
                const response = await fetch('/api/request-file', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        otp: otp,
                        downloaderId: socket.id || 'anonymous'
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Request failed with status ${response.status}: ${errorText}`);
                }
                
                const result = await response.json();
                console.log('üìã Server response:', result);
                
                if (result.success) {
                    showStatus('downloadStatus', 'OTP verified! Searching for file owner...', 'info');
                    
                    // Now request file via P2P
                    socket.emit('request-file', { otp });
                    
                    // Set up timeout for P2P request
                    const requestTimeout = setTimeout(() => {
                        showStatus('downloadStatus', 'File request timed out. File owner may be offline.', 'error');
                    }, 30000); // 30 second timeout
                    
                    // Listen for file request responses
                    socket.once('file-request-failed', (data) => {
                        clearTimeout(requestTimeout);
                        showStatus('downloadStatus', data.error || 'File not found in P2P network.', 'error');
                        console.error('‚ùå P2P file request failed:', data.error);
                    });
                    
                    socket.once('file-transfer-approved', (data) => {
                        clearTimeout(requestTimeout);
                        console.log('‚úÖ File transfer approved by owner:', data.ownerId);
                        showStatus('downloadStatus', 'File owner approved transfer. Establishing P2P connection...', 'info');
                        initiateWebRTCConnection(data.ownerId, otp);
                    });
                    
                    socket.once('file-transfer-rejected', (data) => {
                        clearTimeout(requestTimeout);
                        showStatus('downloadStatus', 'File owner rejected the transfer request.', 'error');
                        console.error('‚ùå File transfer rejected:', data.reason);
                    });
                } else {
                    showStatus('downloadStatus', result.error || 'Invalid or expired OTP.', 'error');
                    console.error('‚ùå OTP verification failed:', result.error);
                }
                
            } catch (error) {
                showStatus('downloadStatus', 'Error requesting file: ' + error.message, 'error');
                console.error('‚ùå Download error:', error);
            }
        }

        // WebRTC P2P connection setup
        async function initiateWebRTCConnection(ownerId, otp) {
            try {
                console.log(`ü§ù Initiating WebRTC connection to ${ownerId}`);
                
                const peerConnection = new RTCPeerConnection(rtcConfig);
                peerConnections.set(ownerId, peerConnection);
                
                // Set up ICE candidate handling
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        console.log('üßä Sending ICE candidate to', ownerId);
                        socket.emit('webrtc-ice-candidate', {
                            targetId: ownerId,
                            candidate: event.candidate
                        });
                    }
                };
                
                // Set up data channel for file transfer with enhanced configuration for faster downloads
                const dataChannel = peerConnection.createDataChannel('fileTransfer', {
                    ordered: true,
                    maxPacketLifeTime: 30000, // 30 second timeout (can't use both maxRetransmits and maxPacketLifeTime)
                    maxRetransmitTime: 30000
                });
                
                // Configure for high-speed transfers
                dataChannel.binaryType = 'arraybuffer';
                
                dataChannel.onopen = () => {
                    console.log('üì°‚úÖ Data channel opened on requester side');
                    showStatus('downloadStatus', 'P2P connection established. Requesting file...', 'info');
                    
                    // Immediately send request when channel opens
                    try {
                        if (dataChannel.readyState === 'open') {
                            dataChannel.send(JSON.stringify({ type: 'request-file', otp }));
                            console.log('üì§ File request sent via data channel');
                        } else {
                            console.error('‚ùå Data channel not ready:', dataChannel.readyState);
                            showStatus('downloadStatus', 'Connection error: Data channel not ready', 'error');
                        }
                    } catch (error) {
                        console.error('‚ùå Error sending file request:', error);
                        showStatus('downloadStatus', 'Error sending file request: ' + error.message, 'error');
                    }
                };
                
                dataChannel.onclose = () => {
                    console.log('üì°‚ùå Data channel closed on requester side');
                };
                
                dataChannel.onerror = (error) => {
                    console.error('üì°üí• Data channel error on requester side:', error);
                };
                
                dataChannel.onmessage = (event) => {
                    handleP2PFileData(event.data, otp);
                };
                
                // Create offer
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                
                // Send offer via signaling server
                socket.emit('webrtc-offer', {
                    targetId: ownerId,
                    offer: offer,
                    otp: otp
                });
                
                console.log('üì§ WebRTC offer sent');
                
            } catch (error) {
                console.error('‚ùå WebRTC connection error:', error);
                showStatus('downloadStatus', 'Failed to establish P2P connection: ' + error.message, 'error');
            }
        }

        // Handle incoming P2P file data with optimized processing
        let fileTransferState = {};
        
        function handleP2PFileData(data, otp) {
            try {
                if (typeof data === 'string') {
                    const message = JSON.parse(data);
                    if (message.type === 'file-info') {
                        console.log('üìÑ Received file info:', message);
                        showStatus('downloadStatus', `Downloading ${message.fileName} (${formatFileSize(message.fileSize)})...`, 'info');
                        
                        // Store file info for proper download with optimized buffer management
                        fileTransferState[otp] = {
                            fileName: message.fileName,
                            fileType: message.fileType,
                            fileSize: message.fileSize,
                            receivedChunks: [],
                            totalReceived: 0,
                            startTime: Date.now(),
                            lastProgressUpdate: 0,
                            chunkBuffer: [] // Buffer for faster processing
                        };
                        console.log(`üéØ File transfer initialized for ${message.fileName}, expecting ${message.fileSize} bytes`);
                        return;
                    }
                }
                
                // Handle binary file data chunks with optimized processing
                if (!fileTransferState[otp]) {
                    console.error('‚ùå No file info found for OTP:', otp);
                    console.error('Available transfer states:', Object.keys(fileTransferState));
                    return;
                }
                
                const state = fileTransferState[otp];
                
                // Ensure we're dealing with ArrayBuffer for consistent byte counting
                let chunkSize = 0;
                if (data instanceof ArrayBuffer) {
                    chunkSize = data.byteLength;
                } else if (data.byteLength !== undefined) {
                    chunkSize = data.byteLength;
                } else if (data.size !== undefined) {
                    chunkSize = data.size;
                } else {
                    chunkSize = data.length || 0;
                }
                
                // Add to buffer for batch processing
                state.chunkBuffer.push(data);
                state.totalReceived += chunkSize;
                
                // Process chunks in batches for better performance (every 10 chunks or when complete)
                const shouldProcessNow = state.chunkBuffer.length >= 10 || state.totalReceived >= state.fileSize;
                
                if (shouldProcessNow) {
                    // Move buffered chunks to main array
                    state.receivedChunks.push(...state.chunkBuffer);
                    state.chunkBuffer = [];
                }
                
                const progress = Math.round((state.totalReceived / state.fileSize) * 100);
                const receivedMB = (state.totalReceived / (1024 * 1024)).toFixed(1);
                const totalMB = (state.fileSize / (1024 * 1024)).toFixed(1);
                const elapsed = (Date.now() - state.startTime) / 1000;
                const speedMBps = elapsed > 0 ? (receivedMB / elapsed).toFixed(1) : '0.0';
                
                // Update progress less frequently for better performance (every 2% or every 2 seconds)
                const now = Date.now();
                const timeSinceLastUpdate = now - state.lastProgressUpdate;
                const shouldUpdateProgress = progress % 2 === 0 || timeSinceLastUpdate > 2000 || state.totalReceived >= state.fileSize;
                
                if (shouldUpdateProgress) {
                    console.log(`üì• Received chunks: ${state.receivedChunks.length + state.chunkBuffer.length}, total: ${receivedMB}MB/${totalMB}MB (${progress}%) @ ${speedMBps} MB/s`);
                    showStatus('downloadStatus', `Downloading ${state.fileName}... ${progress}% (${receivedMB}MB/${totalMB}MB) @ ${speedMBps} MB/s`, 'info');
                    state.lastProgressUpdate = now;
                }
                
                // Check if we have all the data (with a small tolerance for rounding errors)
                if (state.totalReceived >= state.fileSize) {
                    // Process any remaining buffered chunks
                    if (state.chunkBuffer.length > 0) {
                        state.receivedChunks.push(...state.chunkBuffer);
                        state.chunkBuffer = [];
                    }
                    
                    const elapsed = (Date.now() - state.startTime) / 1000;
                    const avgSpeed = (state.fileSize / (1024 * 1024) / elapsed).toFixed(1);
                    console.log(`‚úÖ All file data received in ${elapsed.toFixed(1)}s @ ${avgSpeed} MB/s`);
                    console.log(`üìä Received ${state.receivedChunks.length} chunks totaling ${state.totalReceived} bytes`);
                    
                    // Process file creation immediately without delay
                    try {
                        // Combine all chunks with proper MIME type
                        const blob = new Blob(state.receivedChunks, { type: state.fileType });
                        console.log(`üîß Created blob: ${blob.size} bytes, type: ${blob.type}`);
                        
                        // Trigger download with proper filename and type
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = state.fileName; // Use original filename
                        link.style.display = 'none';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(url);
                        
                        showStatus('downloadStatus', `File "${state.fileName}" downloaded successfully via P2P! (${elapsed.toFixed(1)}s @ ${avgSpeed} MB/s)`, 'success');
                        console.log('üíæ P2P file download complete:', state.fileName, blob.size, 'bytes');
                        
                        // Clean up
                        delete fileTransferState[otp];
                        document.getElementById('otpInput').value = '';
                    } catch (blobError) {
                        console.error('‚ùå Error creating blob:', blobError);
                        showStatus('downloadStatus', 'Error creating downloaded file: ' + blobError.message, 'error');
                    }
                }
                
            } catch (error) {
                console.error('‚ùå Error handling P2P file data:', error);
                showStatus('downloadStatus', 'Error processing downloaded file: ' + error.message, 'error');
            }
        }
        
        // Download file directly in browser
        function downloadFileDirectly(file, fileName) {
            const url = URL.createObjectURL(file);
            const link = document.createElement('a');
            link.href = url;
            link.download = fileName;
            link.style.display = 'none';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }
        
        // Socket event handlers for P2P file sharing
        socket.on('file-request-received', (data) => {
            const { otp, requesterId, fileName } = data;
            console.log(`üì• File request received for ${fileName} from ${requesterId}`);
            
            // Create a custom approval dialog
            showFileRequestApproval(fileName, otp, requesterId);
        });

        function showFileRequestApproval(fileName, otp, requesterId) {
            // Remove any existing approval dialog
            const existingDialog = document.getElementById('approval-dialog');
            if (existingDialog) {
                existingDialog.remove();
            }

            // Create approval dialog
            const dialog = document.createElement('div');
            dialog.id = 'approval-dialog';
            dialog.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                border: 2px solid #333;
                border-radius: 10px;
                padding: 20px;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                z-index: 10000;
                max-width: 400px;
                text-align: center;
            `;
            
            dialog.innerHTML = `
                <h3>üîî File Transfer Request</h3>
                <p>Someone wants to download:</p>
                <p><strong>"${fileName}"</strong></p>
                <p>Allow this transfer?</p>
                <div style="margin-top: 20px;">
                    <button id="approve-btn" style="background: #4CAF50; color: white; padding: 10px 20px; margin: 5px; border: none; border-radius: 5px; cursor: pointer;">
                        ‚úÖ Allow
                    </button>
                    <button id="reject-btn" style="background: #f44336; color: white; padding: 10px 20px; margin: 5px; border: none; border-radius: 5px; cursor: pointer;">
                        ‚ùå Reject
                    </button>
                </div>
            `;
            
            // Add backdrop
            const backdrop = document.createElement('div');
            backdrop.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 9999;
            `;
            
            document.body.appendChild(backdrop);
            document.body.appendChild(dialog);
            
            // Handle approval
            document.getElementById('approve-btn').onclick = () => {
                socket.emit('approve-transfer', { otp, requesterId });
                console.log('‚úÖ File transfer approved');
                backdrop.remove();
                dialog.remove();
            };
            
            // Handle rejection
            document.getElementById('reject-btn').onclick = () => {
                socket.emit('reject-transfer', { otp, requesterId, reason: 'User declined' });
                console.log('‚ùå File transfer rejected');
                backdrop.remove();
                dialog.remove();
            };
            
            // Auto-reject after 30 seconds
            setTimeout(() => {
                if (document.getElementById('approval-dialog')) {
                    socket.emit('reject-transfer', { otp, requesterId, reason: 'Request timed out' });
                    console.log('‚è∞ File transfer request timed out');
                    backdrop.remove();
                    dialog.remove();
                }
            }, 30000);
        }

        // WebRTC signaling handlers
        socket.on('webrtc-offer-received', async (data) => {
            const { senderId, offer, otp } = data;
            console.log(`ü§ù Received WebRTC offer from ${senderId} for OTP ${otp}`);
            
            try {
                const peerConnection = new RTCPeerConnection(rtcConfig);
                peerConnections.set(senderId, peerConnection);
                
                // Set up ICE candidate handling
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        console.log('üßä Sending ICE candidate to', senderId);
                        socket.emit('webrtc-ice-candidate', {
                            targetId: senderId,
                            candidate: event.candidate
                        });
                    }
                };
                
                // Set up data channel for file serving
                peerConnection.ondatachannel = (event) => {
                    const dataChannel = event.channel;
                    console.log('üì° Data channel received for file serving, state:', dataChannel.readyState);
                    
                    // Enhanced channel configuration for high-speed downloads
                    dataChannel.binaryType = 'arraybuffer'; // Ensure consistent binary handling
                    
                    // Optimize buffer settings for faster receiving
                    if (dataChannel.bufferedAmountLowThreshold !== undefined) {
                        dataChannel.bufferedAmountLowThreshold = 1024 * 1024; // 1MB threshold
                    }
                    
                    // Set up channel event handlers
                    dataChannel.onopen = () => {
                        console.log('üì°‚úÖ Data channel opened for file serving');
                    };
                    
                    dataChannel.onclose = () => {
                        console.log('üì°‚ùå Data channel closed on file serving side');
                    };
                    
                    dataChannel.onerror = (error) => {
                        console.error('üì°üí• Data channel error on file serving side:', error);
                        showStatus('uploadStatus', 'Connection error on file serving side', 'error');
                    };
                    
                    dataChannel.onmessage = (event) => {
                        handleP2PFileRequest(event.data, dataChannel, otp);
                    };
                    
                    // Store data channel for monitoring
                    peerConnection.dataChannel = dataChannel;
                };
                
                await peerConnection.setRemoteDescription(offer);
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                
                socket.emit('webrtc-answer', {
                    targetId: senderId,
                    answer: answer
                });
                
                console.log('üì§ WebRTC answer sent to', senderId);
                
            } catch (error) {
                console.error('‚ùå Error handling WebRTC offer:', error);
            }
        });

        socket.on('webrtc-answer-received', async (data) => {
            const { senderId, answer } = data;
            console.log(`ü§ù Received WebRTC answer from ${senderId}`);
            
            const peerConnection = peerConnections.get(senderId);
            if (peerConnection) {
                await peerConnection.setRemoteDescription(answer);
                console.log('‚úÖ WebRTC connection established with', senderId);
            }
        });

        socket.on('webrtc-ice-candidate-received', async (data) => {
            const { senderId, candidate } = data;
            const peerConnection = peerConnections.get(senderId);
            if (peerConnection && candidate) {
                await peerConnection.addIceCandidate(candidate);
                console.log('üßä ICE candidate added from', senderId);
            }
        });

        // Handle P2P file requests from peers
        function handleP2PFileRequest(data, dataChannel, otp) {
            try {
                const message = JSON.parse(data);
                if (message.type === 'request-file' && message.otp === otp) {
                    console.log(`üì§ Serving file for OTP: ${otp}, channel state: ${dataChannel.readyState}`);
                    
                    const fileData = localFiles.get(otp);
                    if (!fileData) {
                        console.error('‚ùå File not found for OTP:', otp);
                        showStatus('uploadStatus', 'File not found for transfer', 'error');
                        return;
                    }
                    
                    // Wait for data channel to be fully open before sending
                    if (dataChannel.readyState !== 'open') {
                        console.log('‚è≥ Data channel not ready, waiting for open event...');
                        showStatus('uploadStatus', 'Waiting for connection to be ready...', 'info');
                        
                        dataChannel.onopen = () => {
                            console.log('üì° Data channel now open, starting file transfer');
                            startFileTransfer(dataChannel, fileData, otp);
                        };
                        
                        // Set a timeout in case the channel never opens
                        setTimeout(() => {
                            if (dataChannel.readyState !== 'open') {
                                console.error('‚ùå Data channel failed to open within timeout');
                                showStatus('uploadStatus', 'Connection timeout - unable to establish P2P link', 'error');
                            }
                        }, 10000); // 10 second timeout
                        
                        return;
                    }
                    
                    console.log('üì° Data channel already open, starting file transfer immediately');
                    startFileTransfer(dataChannel, fileData, otp);
                }
            } catch (error) {
                console.error('‚ùå Error handling P2P file request:', error);
                showStatus('uploadStatus', 'Error handling file request: ' + error.message, 'error');
            }
        }

        // Separate function to handle the actual file transfer
        function startFileTransfer(dataChannel, fileData, otp) {
            // Double-check channel state before starting transfer
            if (dataChannel.readyState !== 'open') {
                console.error('‚ùå Cannot start transfer - data channel not open:', dataChannel.readyState);
                showStatus('uploadStatus', 'Connection error: Unable to start file transfer', 'error');
                return;
            }
            
            console.log('üì° Data channel confirmed open, starting file transfer');
            
            try {
                // Send file info first
                dataChannel.send(JSON.stringify({
                    type: 'file-info',
                    fileName: fileData.fileName,
                    fileSize: fileData.fileSize,
                    fileType: fileData.fileType
                }));
                
                console.log(`üì¶ Sending file: ${fileData.fileName} (${formatFileSize(fileData.fileSize)})`);
                
                // Send file in chunks with flow control for WebRTC stability
                // Using optimized 256KB chunks with larger buffering for better performance
                const chunkSize = 262144; // 256KB chunks for better performance
                const fileBuffer = fileData.file;
                const totalChunks = Math.ceil(fileBuffer.byteLength / chunkSize);
                
                console.log(`üìä Sending ${totalChunks} chunks of ${formatFileSize(chunkSize)} each`);
                
                let chunkIndex = 0;
                let startTime = Date.now();
                let isTransferring = true;
                
                // Monitor data channel buffer to prevent overflows
                function canSendMoreData() {
                    // Increased buffer threshold for better performance: 8MB
                    const bufferThreshold = 8 * 1024 * 1024; // 8MB
                    const currentBuffer = dataChannel.bufferedAmount;
                    const canSend = currentBuffer < bufferThreshold;
                    
                    if (!canSend) {
                        console.log(`‚è≥ Buffer full: ${currentBuffer} bytes (threshold: ${bufferThreshold})`);
                    }
                    
                    return canSend;
                }
                
                function sendNextChunk() {
                    // Check if channel is still open and transfer is active
                    if (!isTransferring || dataChannel.readyState !== 'open') {
                        console.error('‚ùå Data channel closed during transfer, state:', dataChannel.readyState);
                        showStatus('uploadStatus', 'Connection closed during file transfer', 'error');
                        isTransferring = false;
                        return;
                    }
                    
                    // Check if we can send more data (buffer management)
                    if (!canSendMoreData()) {
                        // Wait longer for buffer to drain when it's full
                        setTimeout(sendNextChunk, 200); // Increased wait time
                        return;
                    }
                    
                    if (chunkIndex < totalChunks) {
                        const start = chunkIndex * chunkSize;
                        const end = Math.min(start + chunkSize, fileBuffer.byteLength);
                        const chunk = fileBuffer.slice(start, end);
                        
                        try {
                            // Additional check right before sending
                            if (dataChannel.bufferedAmount > 4 * 1024 * 1024) { // 4MB safety check
                                console.log(`‚ö†Ô∏è Buffer getting full (${dataChannel.bufferedAmount} bytes), waiting...`);
                                setTimeout(sendNextChunk, 150);
                                return;
                            }
                            
                            dataChannel.send(chunk);
                            chunkIndex++;
                            
                            const progress = Math.round((chunkIndex / totalChunks) * 100);
                            const transferredBytes = Math.min(chunkIndex * chunkSize, fileBuffer.byteLength);
                            const transferredMB = (transferredBytes / (1024 * 1024)).toFixed(1);
                            const elapsed = (Date.now() - startTime) / 1000;
                            const speedMBps = elapsed > 0 ? (transferredBytes / (1024 * 1024) / elapsed).toFixed(1) : '0.0';
                            
                            console.log(`üì§ Sent chunk ${chunkIndex}/${totalChunks} (${progress}%) - ${transferredMB}MB @ ${speedMBps} MB/s [Buffer: ${dataChannel.bufferedAmount} bytes]`);
                            
                            // Update upload status with progress and speed
                            showStatus('uploadStatus', `Sending file... ${progress}% (${transferredMB}MB/${formatFileSize(fileBuffer.byteLength)}) @ ${speedMBps} MB/s`, 'info');
                            
                            if (chunkIndex < totalChunks) {
                                // More conservative delay based on buffer size
                                let delay = 25; // Reduced base delay for faster transfers
                                if (dataChannel.bufferedAmount > 6 * 1024 * 1024) { // 6MB
                                    delay = 75;
                                } else if (dataChannel.bufferedAmount > 4 * 1024 * 1024) { // 4MB
                                    delay = 50;
                                }
                                
                                setTimeout(sendNextChunk, delay);
                            } else {
                                const totalTime = (Date.now() - startTime) / 1000;
                                const avgSpeed = (fileBuffer.byteLength / (1024 * 1024) / totalTime).toFixed(1);
                                console.log(`‚úÖ File sent completely via P2P in ${totalTime.toFixed(1)}s @ ${avgSpeed} MB/s`);
                                showStatus('uploadStatus', `File transferred successfully via P2P! (${totalTime.toFixed(1)}s @ ${avgSpeed} MB/s)`, 'success');
                                isTransferring = false;
                            }
                        } catch (error) {
                            console.error('‚ùå Error sending chunk:', error);
                            
                            // If it's a queue full error, wait and retry
                            if (error.message.includes('send queue is full')) {
                                console.log('üîÑ Queue full, waiting before retry...');
                                setTimeout(sendNextChunk, 300); // Wait longer before retry
                                return;
                            }
                            
                            showStatus('uploadStatus', 'Error during file transfer: ' + error.message, 'error');
                            isTransferring = false;
                        }
                    }
                }
                
                // Add error handling for data channel
                dataChannel.onerror = (error) => {
                    console.error('üì°üí• Data channel error during transfer:', error);
                    showStatus('uploadStatus', 'Data channel error during transfer', 'error');
                    isTransferring = false;
                };
                
                dataChannel.onclose = () => {
                    console.log('üì°‚ùå Data channel closed during transfer');
                    if (isTransferring) {
                        showStatus('uploadStatus', 'Connection closed during file transfer', 'error');
                        isTransferring = false;
                    }
                };
                
                // Start sending chunks with minimal delay for faster startup
                setTimeout(sendNextChunk, 50); // Reduced from 300ms to 50ms
                
            } catch (error) {
                console.error('‚ùå Error starting file transfer:', error);
                showStatus('uploadStatus', 'Error starting file transfer: ' + error.message, 'error');
            }
        }

        // Socket event handlers for global notifications
        socket.on('file-available', (data) => {
            const { otp, fileName, fileSize, ownerId } = data;
            if (ownerId !== socket.id) {
                showStatus('transferStatus', `New file "${fileName}" available on P2P network (${formatFileSize(fileSize)})`, 'info');
                console.log('üì¢ File available:', data);
            }
        });
        
        // Utility functions
        function showStatus(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
        }
        
        function displayOTP(otp) {
            const otpDisplay = document.getElementById('otpDisplay');
            otpDisplay.innerHTML = `
                <div class="otp-display">
                    <div>üîê Your P2P OTP Code</div>
                    <div class="otp-code">${otp}</div>
                    <div style="font-size: 0.9rem; color: #666;">
                        Share this code for direct P2P download<br>
                        <strong>File stays on your device ‚Ä¢ True P2P ‚Ä¢ Expires in 5 minutes</strong><br>
                        <small>‚ö†Ô∏è Keep this browser tab open for others to download</small>
                    </div>
                </div>
            `;
            console.log('üîê P2P OTP displayed:', otp);
        }
        
        function generateId() {
            return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
        }
        
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // Initialize the P2P application
        window.onload = function() {
            console.log('üöÄ Global P2P File Sharing System initialized');
        };
    </script>
</body>
</html>
